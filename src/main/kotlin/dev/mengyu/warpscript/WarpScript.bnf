{

    parserClass="dev.mengyu.warpscript.WarpScriptParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="WarpScript"
    psiImplClassSuffix="Impl"
    psiPackage="dev.mengyu.psi"
    psiImplPackage="dev.mengyu.warpscript.psi.impl"

    elementTypeHolderClass="dev.mengyu.warpscript.psi.WarpScriptTypes"
    elementTypeClass="dev.mengyu.warpscript.psi.WarpScriptElementType"
    tokenTypeClass="dev.mengyu.warpscript.psi.WarpScriptTokenType"

    psiImplUtilClass="dev.mengyu.warpscript.psi.impl.SimplePsiImplUtil"

  tokens=[
    LBRACE               =  '{'
    RBRACE               =  '}'
    LBRACK               =  '['
    RBRACK               =  ']'
    LPAREN               =  '('
    RPAREN               =  ')'
    LBLOCK               =  '<%'
    RBLOCK               =  '%>'
    MACRO_PREFIX         = '@'
    VAR_PREFIX           = 'regexp:\!?\$'
    NULL                 = 'NULL'
    T                    = 'T'
    TRUE                 = 'true'
    F                    = 'F'
    FALSE                = 'false'

// control flow
    IFT                  = 'IFT'
    IFTE                 = 'IFTE'

    space='regexp:\s+'
    comment='regexp:(/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/)|(//.*)|(#.*)'

    long='regexp:[\-\+]?\d+'
    hex='regexp:0x\d+'
    bit='0b[01]+'

    double='regexp:[\-\+]?\d+\.\d*'
    sdoule='regexp:[\-\+]?\d+\.\d*[eE][\-\+]?\d*'

    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    mulstring="regexp:<'([^<'>\\]|\\.)*'>" // change to lookup around (?<=<'[\r\n]).*(?<='>)
    id="regexp:[\p{Alnum}!\\\%&()*+,\-./:;<=>?\[\\\]\^_â€˜{|}~]*"// "regexp:[\p{Alnum}\p{Punct}&&[^'@$]]*"
  ]

}

//root ::= !<<eof>> mul_string_expr
root ::= !<<eof>> proc_expr
proc_expr ::=  ( control_expr | ref_expr | typed_expr )*


ref_expr ::=  macro_ref_expr | variable_ref_expr | func_ref_expr
macro_ref_expr ::= MACRO_PREFIX ( literal_long | literal_double | id )
variable_ref_expr ::= VAR_PREFIX ( literal_long | literal_double | id )
func_ref_expr ::= id

macro_expr ::= LBLOCK proc_expr? RBLOCK


// literal expr
bool_literal_expr ::= TRUE | FALSE | T | F
string_literal_expr ::= string | mulstring
literal_expr ::= literal_long | literal_double | string_literal_expr | bool_literal_expr | NULL
literal_long ::= long | hex | bit
literal_double ::= double | sdoule


typed_expr ::=  macro_expr |  list_expr | set_expr | map_expr | literal_expr
one_value_expr ::=  proc_expr [ macro_ref_expr | func_ref_expr ]  // todo

list_expr ::= LBRACK one_value_expr  RBRACK {pin = 1}
set_expr ::= LPAREN one_value_expr  RPAREN {pin = 1}

map_key_expr ::= string | long  | double | NULL
map_value_expr ::=  variable_ref_expr | typed_expr | one_value_expr
map_entry_expr ::= map_key_expr map_value_expr
map_expr ::= LBRACE map_entry_expr*  RBRACE {pin = 1}

//control flow
control_expr ::= ift_control_expr | ifte_control_expr
ift_control_expr ::= [ macro_expr | macro_ref_expr ] [ macro_expr | macro_ref_expr ] IFT
ifte_control_expr ::= ([  macro_expr | macro_ref_expr ])? [ macro_expr | macro_ref_expr ] [ macro_expr | macro_ref_expr ] IFTE